# 자기소개

    영어에 자신 있는 개발자 고정완 입니다. 영어로 된 전공서적과 논문을 읽고 학습 자료를 만드는데 자신 있습니다. 첨부한 포트폴리오에서는 EuroSys 와 ACM 에 등재된 영어 논문 두 편을 읽고 그에 대한 리뷰 소논문을 영어로 작성하였습니다. GPT 와 번역기의 도움 없이 논문을 읽고 영작문을 하였습니다. 포트폴리오에서 표현되는 만큼의 작문 실력과 영어 독해 실력이 있다고 자부합니다. 해당 리뷰 논문을 기반으로 40분 정도의 영어 발표 자료를 만들어서, 발표 및 질의 응답을 진행한 적이 있습니다.
    저는 영어로 하는 소통 뿐만 아니라, 영어로 된 고객 피드백을 받고 글로벌한 서비스를 개발해 나가는데 익숙합니다. 첫 회사였던 이큐브랩에서는 미국 볼티모어를 대상으로 서비스를 하는 제품을 만들었고, 현재 재직중인 드림포라에서는 영미권 사람들을 대상으로 하는 앱을 만들고 있습니다. 드림포라에서 누적 다운로드 200만을 달성한 이후에는 미국 App Store 의 Editor 에게 “The Best App for Self-Care” 로 선정 받았습니다.
    저는 영어로 된 서비스를 개발하는 것을 넘어서, 한국어에 익숙하지 않은 외국인과 협업하는 일에도 능합니다. 드림포라에서는 컨텐츠 및 커뮤니티 매니저로 채용된 남아프리카 공화국과 캐나다 국적의 동료들과 함께 일을 하였습니다. 외국인 동료들과 소통하는데 거부감이 없으며, 업무 외에도 같이 농담을 하거나 식사를 편안히 할 수 있습니다. 최근에는 버클리 대학교에서 한국으로 교환학생을 온 인턴과 함께 일을 할 기회가 있었는데, 드림포라 앱에 관한 배경지식을 알려주기 위해 함께 영어로 이벤트 스토밍을 진행한 적이 있습니다.
    저는 영어가 모국어인 사람들 뿐만 아니라, 영어에 익숙하지 않은 외국인과도 영어로 소통할 수 있습니다. 저는 서울대학교 사회발전 발전 연구소가 개최한 포럼에서, 영어와 한국어가 익숙하지 않은 중앙아시아 사람들을 대상으로 영어와 한국어 통역 활동을 한 적이 있습니다. 영어와 한국어에 익숙하지 않은 사람들을 위해, 러시아로 간단한 인사와 자기소개를 외워갔으며, 러시아어로 분위기를 풀은 후에는 영어와 손짓 발짓을 통해 소통했습니다. 수학계의 노벨상인 필즈상 수상식이 한국에서 열려 봉사자로 참여한 적이 있는데, 세계 각국에서 온 외국인 참석자들이 영어에 익숙하지 않을 경우 수학 기호를 통해 의사 소통하여 무사히 행사를 안내했던 경험이 있습니다.
    저는 재직 중인 회사에서 개발팀을 이끌고 교육하는 일을 꾸준히 해왔습니다. 처음에 드림포라에 합류했을 때, 연세대학교 연구실을 빌려 사용하는 소규모 창업팀이었던지라 대학교를 갓 졸업한 주니어 분들로 팀이 구성되어 있었습니다. git 을 사용하는 방법부터 가르쳐서 형상관리를 도입했고, 코드리뷰 문화를 도입하기 위해 굉장히 노력했습니다. 드림포라에 합류했을 떄의 개발 포지션은 웹과 백엔드 개발자였지만, 모바일을 담당하던 팀원들과 소통하기 위해 NEXTSTEP 의 Kotlin TDD 과정과 안드로이드 아키텍쳐 With TDD 과정을 완주했습니다. NEXTSTEP 에서 배운 내용을 바탕으로 안드로이드 권장 아키텍처를 도입했으며, 아키텍처에 대한 팀원들의 이해도가 높아질 수 있도록 꾸준한 코드 리뷰와 스터디를 병행하였습니다.
    백엔드 개발자로써 제가 재직중인 회사에서 일궈낸 성과는 다음과 같습니다. 첫째, 웹 호스팅 업체에게 서버를 임대하여 진행하던 서비스를 AWS 클라우드로 이전하였습니다. 둘째, 서버가 죽었을 경우를 대비한 이중화를 하고 보안을 위해 DB 망 분리를 했습니다. 셋째, 단위 테스트와 인수 테스트를 도입하고 Rest Docs 를 통한 문서화를 도입했습니다. 넷째, 배포 시 서비스가 정지하는 일을 막기 위해 무중단 배포 파이프라인을 구축했습니다. 다섯째, 서버의 헬스체크와 모니터링 시스템을 구축했습니다. 여섯째, DB 스키마를 리모델링을 하고 데이터 마이그레이션을 하였습니다.
    드림포라에 처음 입사했을 때, 경영진은 외주를 통해 서버 개발과 유지보수를 하고 있었습니다. 서버는 웹 호스팅 업체에서 임대한 서버로 운영되고 있었고, AWS 의 스타트업 크레딧을 활용하고 싶었던 경영진은 저에게 클라우드로의 서버 이전 업무를 맡겼습니다. 기존 서버는 월 50만원짜리 단일 WAS 와, 150 만원 짜리 단일 DB 서버로 호스팅되어 있었고, 두 개의 서버 모두 public 하게 공개되어 있었습니다. AWS  로 이전을 하며 VPC 를 활용해 EC2 WAS와 RDS 를 사설망으로 분리했고, 로드밸런서와 bastion 용 EC2 서버 하나를 인터넷 네트워크에 공개했습니다. 스타트업 크레딧은 메가존 클라우드를 통해 지원받았기에, 메가존 클라우드에게 필요한 권한은 IAM Role 을 부여하여 제공했습니다. 이전을 하며 망분리와 WAS 이중화, RDS 의 백업 설정을 하였고, 기존 서버가 컨테이너화 되어 있지는 않았기에 기존 서버의 운영체제 설정을 터미널을 통해 하나하나 분석하며 옮겼습니다. 다음에 또 이렇게 서버를 옮겨야 할 때 터미널로 서버 설정을 확인하기 힘들 것 같아, 분석하는 김에 서버환경과 관련한 도커 파일을 작성하였습니다.
    클라우드로의 이전을 하며 겪었던 가장 큰 문제는 DNS 였습니다. 도메인 권한을 가진 서버를 가리키는 Name Server 의 TTL 은 172800 초였고, 그로 인해 48시간 동안은 라우터의 캐시에 따라 네트워크 패킷이 새로 만든 AWS 서버와 기존의 웹 호스팅 서버 중에 어디로 갈지 모르는 상태가 되었습니다. 다행히 패킷이 길을 잃는 원인이 네트워크 라우터 캐시의 TTL 때문이라는 것을 알았기에, 과거의 웹 호스팅 서버로 패킷이 도착할 경우 새로 만든 AWS 서버로 Redirect될 수 있도록 중개하는 서버를 사이에 끼워 넣었습니다.
    클라우드로 서버를 마이그레이션 한 이후에는 백엔드 서버를 리팩토링하기 시작했습니다. 외주를 통해 개발된 Spring 서버는 Controller 에 모든 로직이 존재하고, DTO 와 도메인 모델 구분이 되어있지 않았습니다. 특히 로그인을 하고 나면 서비스가 굉장히 느려지는 문제가 있었는데, 원인을 추적해보니 세션이 WAS 의 메모리가 아니라 RDB 의 테이블을 활용해 동작하고 있던 게 원인이었습니다. JSessionId 별로 row 가 새로 생성되고 있었고 심지어 인덱스가 전혀 걸려있지 않았습니다. 따라서 로그인을 하고 나면 그 이후로의 모든 API 동작은 8천만 개 정도의 row 가 쌓인 테이블을 항상 풀스캔을 하며 동작을 하고 있었습니다.  풀스캔 때문에 느려지는 문제를 DB 의 스펙을 올려가는 방식으로 해결해왔지만, 지금과 같은 상황에서는 설사 사용자가 많지 않더라도 서버를 오래 켜둘 수록 느려지기 때문에 그대로 놔둘 수가 없다고 판단했습니다. 응급처치로 세션을 RDB 가 아닌, Redis 로 옮겼고 날짜가 반년 이상 오래된 세션들을 모두 삭제하는 작업을 진행했습니다. 응급처치 후 앱의 실제 요구사항을 살펴보니 세션이 필요한 로직이 거의 없어서, 이 참에 JWT 기반의 stateless 형태로 서버를 리팩토링하기로 하였습니다.
    외주를 통해 개발된 서버라 그런지 API 인터페이스에 관한 문서화가 전혀 되어 있지 않았습니다. 심지어 필드의 이름도 통일되어 있지 않습니다. 어떤 API 에서는 비공개 여부를 나타내는데 isPrivate 을 쓰는가 하면, 어떤 곳에서는 그냥 private 이라고 되어 있었습니다. 안드로이드 측에 제대로 된 API 문서가 제공되고 있지 않다보니, 서버의 인터페이스와 안드로이드에서 보내는 JSON 이 일치하지 않아서 발생하는 버그도 무척 많았습니다. 이 혼란을 해결하려면 서버의 코드가 아니라, 안드로이드 코드와 요구사항 문서를 보고 서버를 전부 다 새로 구현하는 게 빠르다는 판단을 했습니다. 서버 리팩토링을 위해 안드로이드 코드를 기반으로 서버가 어떤 Request 를 받아서 어떤 Response 를 보내주어야 하는지에 대한 인수 테스트를 작성했습니다. 그렇게 작성한 인수 테스트는 REST Docs 를 통해 문서화 하여, 안드로이드 동료에게 제가 실수한 부분은 없는지 한번 더 검수를 받았습니다. 작성한 인수 테스트에 확신이 들면 제가 새로 작성한 DTO 와 Controller 를 기존 서버의 로직과 연결했습니다. 기존 서버에 Layer 가 분리되어 있지 않았기 때문에 기존의 Controller 를 Service 객체로 이름을 바꾸었습니다. 안드로이드에서 사용하고 있는 모든 API 의 호출 성공 시나리오에 대한 인수 테스트를 모두 작성한 다음에는, 비대해져 있는 Service 의 로직을 도메인 객체로 옮기는 리팩토링을 하였습니다. 단위 테스트를 작성하며 리팩토링을 하였고, 리팩토링을 마치고 나니 테스트 커버리지가 80% 에 도달해 있었습니다.
    리팩토링을 마무리하여 신규 기능을 개발 속도가 빨라지고 나서는 무중단 배포 파이프라인을 구축할 필요가 생겼습니다. 그전에는 사용자에게 공지를 띄우고 배포를 하는 5분 동안 서비스를 중지했었는데, 그런 불편함이 자주 생기지 않도록 무중단 배포 파이프라인을 구축했습니다. Dev 와 Stage 서버의 경우에는 NGINX 를 통해 포트를 바꾸는 형식의 Blue-Green 배포 방식을 취했습니다. 빌드와 배포 서버 비용을 아끼고 싶었기 때문에, 배포를 하는 모든 내용은 직접 shell script 로 작성하여 자동화 하였습니다. Production 서버의 경우에는 ECS 를 활용한 Rolling 배포 방식을 도입했습니다.
    서버를 리팩토링 했지만, DB 스키마 구조로 인한 문제는 여전히 남아있었습니다. 인덱스가 제대로 걸려있지 않았던 것도 문제였지만, 스키마가 제대로 설계되어 있지 않아서 쿼리를 작성하는 일 또한 쉽지가 않았습니다. 가령 요구사항에서는 명백히 다른 엔티티로 정규화 되어야 함에도, 하나의 테이블에 지나치게 많이 통합되어 있는 경우가 많았습니다. JOIN 쿼리를 짜기 힘들 정도로 통합된 경우에는 재귀 쿼리를 사용하는 경우가 많았는데, 재귀의 정지조건이 올바르지 못한 경우에는 성능이 급격하게 느려지는 현상이 종종 발생하였습니다. 이렇게 급격하게 느려질 때는 DB 의 리소스를 많이 잡아먹어서, 무거운 쿼리가 존재하는 서비스와 상대적으로 가벼운 서비스를 아예 별도 DB 와 서버로 분리해야 하나를 고민했었습니다. 하지만 스키마를 재설계하지 않으면 기술 부채가 되어 계속 문제가 생길 것 같아서, 스키마를 3정규형까지 정규화 한 후 쿼리 필요에 따라 다시 통합하였습니다. 이 과정을 통해 좋아졌던 첫번째 부분은 재귀 쿼리를 사용하던 부분을 JOIN 쿼리로 해결할 수 있게 되었다는 점이었고, 두번째 부분은 지나치게 통합되어 nullable 을 허용해야만 하던 필드들에게 NOT NULL 조건을 붙일 수 있게 되었다는 점이었습니다.
    하지만 이렇게 새로 설계한 스키마로 기존 데이터를 마이그레이션 하려니 형태가 달라진 만큼 굉장히 복잡한 마이그레이션 로직이 필요하게 되었습니다. 마이그레이션을 쿼리로 짰다가는 검증이 무척 힘들 것 같아서, JPA 로 마이그레이션 로직을 작성하고 테스트 코드로 검증하였습니다. 단, JPA 로 대규모 INSERT 를 할 경우, 해당 엔티티가 isNew 인지 확인하여 persist 혹은 merge 를 하는 비효율이 발생하였고 rewriteBatchedStatements 옵션만으로는 해결이 되지 않아서, Persistable 인터페이스를 상속해 isNew 가 항상 true 이도록 하였습니다. 이렇게 하니 2시간 넘게 걸리던 마이그레이션 배치 작업이 10분 정도로 줄어들게 되었고, 고객에게 30분 정도의 점검시간을 가지겠다고 공지한 후 마이그레이션을 진행할 수 있었습니다.
    DataDog 과 같은 서비스 모니터링 솔루션은 경영진이 돈을 아끼고 싶어했기에 도입하지 못했습니다. 헬스 체크와 메트릭 이상은 CloudWatch 를 통해 알람이 울리도록 할 수 있었지만, 디버깅을 위해서라도 API 비정상 호출 시의 Request 와 Response 는 로그를 남길 필요가 있다고 생각했습니다. 처음에는 API 비정상 호출 로그를 AOP 를 통해 구현했습니다. Audit 기능을 사용하기 편했고, Request 및 Response 를 CachingWrapper 로 감싸는 번거로움이 없었기 때문입니다. 하지만 AOP 를 통한 로깅은 Spring Security 의 필터를 통해 비정상 종료되는 로그를 기록하지 못했고, 그렇기에 로깅을 하는 필터 체인을 직접 구현해 끼워 넣었습니다. API 요청 응답에 관한 로깅은 데이터 양이 많았고, 실서비스에 영향이 가지 않도록 별개의 DB 서버에 저장하도록 했습니다. 1차로 DB 에 저장된 로그는 2주가 지나면 배치작업을 통해 S3 로 옮겨져서 용량으로 인한 비용이 발생하지 않도록 하였습니다.
    저는 현재 회사에서 근무하며 자랑스러운 일이 두가지 있습니다. 하나는 신규 기능 개발을 하느라 바쁜 와중에도 리팩토링에 대한 욕심을 포기하지 않았다는 점입니다. 설령 잠을 4시간 이하로 줄이는 한이 있더라도, 외주 수준의 개발 품질에 남아있고 싶지 않았습니다. 두번째는 이 모든 리팩토링을 저 혼자의 독단으로 진행한 게 아니라, 개발을 잘 모르는 경영진을 설득하며 진행했다는 점입니다. 개발 용어로 경영진과 이야기를 한 게 아니라, DAU 와 같은 투자에 있어서 중요한 KPI 수치를 통해 버그를 잡아야할 필요성과 서버가 죽는 불안정성을 해결할 필요를 설득했습니다. 서버가 몇 시간만 죽어도 그날의 DAU 수치가 굉장히 나쁘게 나오기 때문에, 이중화와 인프라 구축에 들어가는 리소스의 필요성을 경영진에게 설득할 수 있었습니다. 버그는 VOC 를 통해 고객 평가가 나쁘다는 점을 경영진에게 알렸고, 버그가 재발하지 않기 위해서는 테스트 코드에 시간을 써야만 한다고 경영진을 설득했습니다. 수면 시간이 부족했지만, 신규 기능 개발과 리팩토링을 병행하며 2년간 서비스를 운영했습니다. 그리고 저의 지식과 경험이 부족한 일이 생기면, 혼자서 해결하는 게 아니라 NEXTSTEP 과 같은 커뮤니티에 참여하여 적극적인 스터디를 통해 실무의 문제를 해결하였습니다.
